# 第七章：打造专属流水线

—— 摆脱黑盒，自研 HelloAgents 框架

## 📖 荒岛日记：第 7 天

昨天建立的"AutoGen 建筑公司"虽然能盖房子，但我发现了一个致命问题：官僚主义。

当我命令 Friday 去悬崖边采摘燕窝时，那个基于通用模板生成的"工人 Friday"竟然拒绝执行。他不仅消耗了大量口粮（Token）来跟我反复确认安全协议，还因为框架内部复杂的握手流程卡顿了半天。

通用框架就像是一套均码的宇航服，虽然安全，但在丛林里抓兔子时却笨重得要把人累死。

我看了一眼那个写着"AutoGen"的集装箱，摇了摇头。

"在这个岛上，我不想要黑盒。我要掌控每一个神经元的流动。"

我决定拆掉那些沉重的外骨骼，只保留最核心的芯片（LLM）。我要用最基础的 Python 代码，为 Friday 量身打造一套轻便、透明、完全可控的骨架。

我给这套新系统取名为——HelloAgents。

---

## 🛠️ 技术生存手册：为什么要造轮子？

在篝火旁，我重新审视了我的开发策略。在《从零开始构建智能体》的教程中，这是从"调包侠"到"架构师"的质变。

### 1. 通用框架 vs. 自研框架

**通用框架 (LangChain/AutoGen)**:

- 优点：功能全，开箱即用。
- 缺点：封装太深（Wrapper hell）。有时候你只想让 Agent 说句话，框架却在后台跑了十几个中间件，出了 Bug 根本找不到在哪里。

**自研框架 (HelloAgents)**:

- 核心：直接调用 OpenAI 原生 API。
- 逻辑：Agent = LLM + Memory + Tools。
- 优势：透明可控。你可以精确控制 Friday 在思考时的每一个标点符号，也能随意插拔他的组件。

### 2. 核心架构图

我在沙地上画出了 HelloAgents 的蓝图，这不再是复杂的工厂流水线，而是一个精密的生物解剖图：

```
Agent 对象
├── Profile (人设): 你是谁？（System Prompt）
├── Memory (记忆): 你经历过什么？（Messages List）
├── Planning (思考): 下一步做什么？（Thinking Method）
└── Action (行动): 手里有什么工具？（Tools Definition）
```

---

## 💻 开发者日志：颁发"身份证"

我打开 IDE，深吸一口气。这一次，我不再调用别人的库，我要定义 Class。

这一步在小说中，相当于我在给荒岛上的野人颁发身份证和职业手册。

```python
# HelloAgents 框架的核心代码：定义生命

class Agent:
    def __init__(self, name, role, model="gpt-4"):
        """
        初始化：给 Friday 发身份证
        """
        self.name = name
        self.role = role  # 比如 "生存专家"
        self.model = model

        # 记忆系统：这是他的大脑皮层，初始只有出厂设置（System Prompt）
        self.memory = [
            {"role": "system", "content": f"你叫{name}。你的职业是{role}。"}
        ]

    def think(self, user_input):
        """
        思考过程：这是直接调用 OpenAI API 的地方，没有中间商赚差价
        """
        # 1. 把新听到的存入记忆
        self.memory.append({"role": "user", "content": user_input})

        # 2. 调用大脑 (LLM)
        response = client.chat.completions.create(
            model=self.model,
            messages=self.memory
        )

        # 3. 获取想法
        thought = response.choices.message.content

        # 4. 记住自己的想法（形成连贯意识）
        self.memory.append({"role": "assistant", "content": thought})

        return thought

    def action(self, tool_name):
        # ... 这里定义工具调用的逻辑 ...
        pass
```

写完这段代码，我按下了运行键。

"Friday，系统重置。加载 HelloAgents 内核。"

这一次，Friday 没有任何多余的动作。他站得笔直，眼神清澈。

我试探性地发出指令："Friday，去悬崖采燕窝。不需要安全协议，不需要反复确认，直接规划路线。"

Friday 的处理速度快得惊人。因为没有了通用框架那几十层的包装，他的思维直达行动：

"收到。检测到风向东南。规划路线：沿藤蔓攀爬。预计耗时 5 分钟。执行中。"

他像一只灵活的猴子一样窜上了悬崖。

看着他矫健的身影，我感到前所未有的踏实。这就是 Code-Native 的力量。

我不再是依赖集装箱的幸存者，我是制定这片岛屿物理法则的神。

然而，随着 Friday 变得越来越聪明，记录的日志（Memory）越来越长，我发现他的反应开始变慢了。他经常记不住昨天吃剩的鱼放在哪了。

HelloAgents 虽然给了他灵活的身体，但他的脑容量（Context Window）是有限的。

下一章，我需要给他做一个"外挂大脑"——向量数据库。
